# Client Need: EchoSub Database Module

## Overview

A Golang-based database access module for EchoSub that provides type-safe database operations using sqlc-generated code, schema management via Atlas, and connection handling via pgx. The module manages all interactions with the PostgreSQL database for the subtitle platform's core pipeline: video fingerprinting, transcriptions, and translations.

**This module is designed as a reusable package** that exposes a clean API for database operations. All other EchoSub services (running in AWS Lambda) will use this package to access the database.

## Platform Support

### Target Environment

- **Runtime**: AWS Lambda (Docker containers)
- **Database**: PostgreSQL 16
  - **Development/Test**: Local Docker container
  - **Production**: Supabase (using serverless connection URL)

### Connection Strategy

The module connects via a `DATABASE_URL` environment variable. In production, this is Supabase's serverless-optimized connection URL with built-in connection pooling. The module does not implement its own connection pooling — it relies on the provider's infrastructure.

## Architecture

### Module Design Philosophy

The database module must be implemented as a **standalone, importable Go package** with:

- Schema defined declaratively using Atlas
- Type-safe queries generated by sqlc
- Connection management via pgx
- Environment-based configuration (DATABASE_URL)
- No ORM magic — plain SQL, predictable behavior

### Toolchain

| Tool | Purpose |
|------|---------|
| **Atlas** | Declarative schema definition and migrations |
| **sqlc** | Generates type-safe Go code from SQL queries |
| **pgx** | PostgreSQL driver for Go |

### Directory Structure

```
prethora/echosub_db/
├── atlas.hcl                 # Atlas configuration
├── schema.hcl                # Declarative database schema
├── migrations/               # Generated migration files
│   └── ...
├── queries/                  # SQL query files for sqlc
│   ├── videos.sql
│   ├── transcriptions.sql
│   ├── translations.sql
│   └── jobs.sql
├── sqlc.yaml                 # sqlc configuration
├── db.go                     # Connection management, public API
├── generated/                # sqlc-generated code (do not edit)
│   ├── models.go
│   ├── db.go
│   ├── videos.sql.go
│   ├── transcriptions.sql.go
│   ├── translations.sql.go
│   └── jobs.sql.go
├── docker/                   # Local development setup
│   └── psql/
│       ├── Dockerfile
│       └── init-multiple-databases.sh
├── Makefile                  # Development commands
└── README.md
```

## Database Schema

### videos

Stores video fingerprints for identification. A video is uniquely identified by its visual fingerprint (duration + frame hashes).

| Column | Type | Description |
|--------|------|-------------|
| id | UUID | Primary key |
| duration_ms | INTEGER | Video duration in milliseconds |
| hash_10 | BIGINT | Perceptual hash at 10% position |
| hash_25 | BIGINT | Perceptual hash at 25% position |
| hash_50 | BIGINT | Perceptual hash at 50% position |
| hash_75 | BIGINT | Perceptual hash at 75% position |
| hash_90 | BIGINT | Perceptual hash at 90% position |
| youtube_id | VARCHAR(20) | Optional YouTube video ID (fast path) |
| title | TEXT | Optional title for display |
| created_at | TIMESTAMPTZ | Creation timestamp |

**Indexes:**
- Primary key on `id`
- Index on `duration_ms` for fingerprint matching
- Unique index on `youtube_id` (where not null)

### transcriptions

Stores source language transcription from Whisper. One transcription per video.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID | Primary key |
| video_id | UUID | Foreign key to videos |
| language | VARCHAR(10) | ISO 639-1 language code (e.g., 'en', 'ko') |
| segments | JSONB | Array of {start, end, text} segments |
| segment_count | INTEGER | Number of segments |
| created_at | TIMESTAMPTZ | Creation timestamp |

**Constraints:**
- Unique on `video_id` (one transcription per video)
- Foreign key to videos with CASCADE delete

### translations

Stores translated subtitles. One translation per (video, language) pair.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID | Primary key |
| video_id | UUID | Foreign key to videos |
| transcription_id | UUID | Foreign key to transcriptions |
| language | VARCHAR(10) | Target language ISO 639-1 code |
| segments | JSONB | Array of {start, end, text} segments |
| segment_count | INTEGER | Number of segments |
| created_at | TIMESTAMPTZ | Creation timestamp |

**Constraints:**
- Unique on `(video_id, language)`
- Foreign keys with CASCADE delete

### jobs

Tracks processing pipeline state.

| Column | Type | Description |
|--------|------|-------------|
| id | UUID | Primary key |
| video_id | UUID | Foreign key to videos (nullable until fingerprint created) |
| target_language | VARCHAR(10) | Target language for translation |
| status | TEXT | One of: pending, uploading, transcribing, translating, splitting, complete, failed |
| error_message | TEXT | Error details if failed |
| audio_key | TEXT | Storage key for uploaded audio |
| audio_duration_ms | INTEGER | Duration of audio |
| created_at | TIMESTAMPTZ | Creation timestamp |
| started_at | TIMESTAMPTZ | When processing started |
| completed_at | TIMESTAMPTZ | When processing completed |

**Indexes:**
- Index on `status` for worker queries
- Index on `video_id` (where not null)

## Public API Surface

```go
package echosubdb

import (
    "context"
    "time"
)

// Segment represents a single subtitle segment.
type Segment struct {
    Start float64 `json:"start"` // Start time in seconds
    End   float64 `json:"end"`   // End time in seconds
    Text  string  `json:"text"`  // Subtitle text
}

// Video represents a video identified by its fingerprint.
type Video struct {
    ID         string
    DurationMs int32
    Hash10     int64
    Hash25     int64
    Hash50     int64
    Hash75     int64
    Hash90     int64
    YoutubeID  *string
    Title      *string
    CreatedAt  time.Time
}

// Transcription represents a source language transcription.
type Transcription struct {
    ID           string
    VideoID      string
    Language     string
    Segments     []Segment
    SegmentCount int32
    CreatedAt    time.Time
}

// Translation represents a translated subtitle.
type Translation struct {
    ID              string
    VideoID         string
    TranscriptionID string
    Language        string
    Segments        []Segment
    SegmentCount    int32
    CreatedAt       time.Time
}

// JobStatus represents the processing state of a job.
type JobStatus string

const (
    JobStatusPending      JobStatus = "pending"
    JobStatusUploading    JobStatus = "uploading"
    JobStatusTranscribing JobStatus = "transcribing"
    JobStatusTranslating  JobStatus = "translating"
    JobStatusSplitting    JobStatus = "splitting"
    JobStatusComplete     JobStatus = "complete"
    JobStatusFailed       JobStatus = "failed"
)

// Job represents a processing job.
type Job struct {
    ID              string
    VideoID         *string
    TargetLanguage  string
    Status          JobStatus
    ErrorMessage    *string
    AudioKey        *string
    AudioDurationMs *int32
    CreatedAt       time.Time
    StartedAt       *time.Time
    CompletedAt     *time.Time
}

// Fingerprint contains the data needed to identify a video.
type Fingerprint struct {
    DurationMs int32
    Hash10     int64
    Hash25     int64
    Hash50     int64
    Hash75     int64
    Hash90     int64
}

// VideoMatch represents a matched video with its similarity score.
type VideoMatch struct {
    Video       Video
    AvgDistance float64
}

// DB provides database operations for EchoSub.
type DB struct {
    // contains unexported fields
}

// New creates a new DB instance using the provided database URL.
func New(ctx context.Context, databaseURL string) (*DB, error)

// Close closes the database connection.
func (db *DB) Close()

// --- Video Operations ---

// CreateVideo inserts a new video record.
func (db *DB) CreateVideo(ctx context.Context, v Video) (Video, error)

// GetVideo retrieves a video by ID.
func (db *DB) GetVideo(ctx context.Context, id string) (Video, error)

// GetVideoByYouTubeID retrieves a video by YouTube ID (fast path).
func (db *DB) GetVideoByYouTubeID(ctx context.Context, youtubeID string) (Video, error)

// FindVideosByFingerprint finds videos matching the given fingerprint.
// Returns videos where average Hamming distance across all 5 hashes <= maxAvgDistance.
// Duration tolerance is ±100ms.
func (db *DB) FindVideosByFingerprint(ctx context.Context, fp Fingerprint, maxAvgDistance float64) ([]VideoMatch, error)

// --- Transcription Operations ---

// CreateTranscription inserts a new transcription.
func (db *DB) CreateTranscription(ctx context.Context, t Transcription) (Transcription, error)

// GetTranscription retrieves a transcription by ID.
func (db *DB) GetTranscription(ctx context.Context, id string) (Transcription, error)

// GetTranscriptionForVideo retrieves the transcription for a video.
func (db *DB) GetTranscriptionForVideo(ctx context.Context, videoID string) (Transcription, error)

// TranscriptionExistsForVideo checks if a transcription exists for a video.
func (db *DB) TranscriptionExistsForVideo(ctx context.Context, videoID string) (bool, error)

// --- Translation Operations ---

// CreateTranslation inserts a new translation.
func (db *DB) CreateTranslation(ctx context.Context, t Translation) (Translation, error)

// GetTranslation retrieves a translation by ID.
func (db *DB) GetTranslation(ctx context.Context, id string) (Translation, error)

// GetTranslationForVideo retrieves a specific translation for a video.
func (db *DB) GetTranslationForVideo(ctx context.Context, videoID string, language string) (Translation, error)

// ListTranslationsForVideo retrieves all translations for a video.
func (db *DB) ListTranslationsForVideo(ctx context.Context, videoID string) ([]Translation, error)

// TranslationExistsForVideo checks if a translation exists for a video+language.
func (db *DB) TranslationExistsForVideo(ctx context.Context, videoID string, language string) (bool, error)

// --- Job Operations ---

// CreateJob inserts a new job.
func (db *DB) CreateJob(ctx context.Context, j Job) (Job, error)

// GetJob retrieves a job by ID.
func (db *DB) GetJob(ctx context.Context, id string) (Job, error)

// UpdateJobStatus updates the status of a job.
func (db *DB) UpdateJobStatus(ctx context.Context, id string, status JobStatus, errorMessage *string) error

// SetJobVideoID sets the video ID for a job (after fingerprint is created).
func (db *DB) SetJobVideoID(ctx context.Context, id string, videoID string) error

// ListJobsByStatus retrieves all jobs with a given status.
func (db *DB) ListJobsByStatus(ctx context.Context, status JobStatus) ([]Job, error)
```

## Consumer Usage Pattern

```go
package main

import (
    "context"
    "log"
    "os"
    
    echosubdb "github.com/prethora/echosub_db"
)

func main() {
    ctx := context.Background()
    
    // Initialize from environment
    db, err := echosubdb.New(ctx, os.Getenv("DATABASE_URL"))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // Fast path: check by YouTube ID
    video, err := db.GetVideoByYouTubeID(ctx, "dQw4w9WgXcQ")
    if err == echosubdb.ErrNotFound {
        // Fingerprint matching path
        matches, err := db.FindVideosByFingerprint(ctx, echosubdb.Fingerprint{
            DurationMs: 1823000,
            Hash10:     0x1234567890abcdef,
            Hash25:     0x234567890abcdef1,
            Hash50:     0x34567890abcdef12,
            Hash75:     0x4567890abcdef123,
            Hash90:     0x567890abcdef1234,
        }, 6.0)
        if err != nil {
            log.Fatal(err)
        }
        
        if len(matches) > 0 {
            video = matches[0].Video
        }
    }
    
    // Check for existing translation
    exists, _ := db.TranslationExistsForVideo(ctx, video.ID, "ko")
    if exists {
        translation, _ := db.GetTranslationForVideo(ctx, video.ID, "ko")
        // Use translation.Segments...
    }
}
```

## Fingerprint Matching

The fingerprint matching algorithm uses Hamming distance to compare perceptual hashes:

1. **Filter by duration**: ±100ms tolerance (exact match preferred)
2. **Calculate Hamming distance**: XOR + popcount for each of 5 hashes
3. **Average distance**: Sum of 5 distances / 5
4. **Match threshold**: Average distance ≤ 6 bits

The Hamming distance calculation is implemented as a PostgreSQL function:

```sql
CREATE FUNCTION hamming_distance(a BIGINT, b BIGINT) RETURNS INTEGER AS $$
    SELECT bit_count(a # b)::INTEGER;
$$ LANGUAGE SQL IMMUTABLE PARALLEL SAFE;
```

## Error Handling

```go
package echosubdb

import "errors"

var (
    // ErrNotFound indicates the requested record does not exist.
    ErrNotFound = errors.New("echosubdb: not found")
    
    // ErrDuplicateKey indicates a unique constraint violation.
    ErrDuplicateKey = errors.New("echosubdb: duplicate key")
    
    // ErrConnection indicates a database connection failure.
    ErrConnection = errors.New("echosubdb: connection failed")
)
```

## Local Development Setup

### Docker Configuration

The module includes Docker configuration for local PostgreSQL:

**docker/psql/Dockerfile:**
```dockerfile
FROM postgres:16
COPY init-multiple-databases.sh /docker-entrypoint-initdb.d/
RUN chmod +x /docker-entrypoint-initdb.d/init-multiple-databases.sh
```

**docker/psql/init-multiple-databases.sh:**
```bash
#!/bin/bash
set -e
set -u

function create_database() {
  local database=$1
  echo "Creating database '$database'"
  psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
CREATE DATABASE $database;
EOSQL
}

if [ -n "$POSTGRES_MULTIPLE_DATABASES" ]; then
  echo "Multiple database creation requested: $POSTGRES_MULTIPLE_DATABASES"
  for db in $(echo $POSTGRES_MULTIPLE_DATABASES | tr ',' ' '); do
    create_database $db
  done
  echo "Multiple databases created"
fi
```

### Makefile Commands

```makefile
# Docker
docker-build:
	docker build -t echosub-psql ./docker/psql

docker-create:
	docker create --name echosub-psql-container \
		-e POSTGRES_PASSWORD=123456 \
		-e POSTGRES_MULTIPLE_DATABASES=development,test \
		-v "$(PWD)/docker/psql/data:/var/lib/postgresql/data" \
		-p 5432:5432 \
		echosub-psql

docker-start:
	docker start echosub-psql-container

docker-stop:
	docker stop echosub-psql-container

# Schema & Migrations
migrate-diff:
	atlas migrate diff --env local

migrate-apply:
	atlas migrate apply --env local

migrate-apply-test:
	atlas migrate apply --env test

# Code Generation
generate:
	sqlc generate

# Development
dev-setup: docker-build docker-create docker-start migrate-apply
	@echo "Development environment ready"

# Testing
test:
	DATABASE_URL="postgres://postgres:123456@localhost:5432/test?sslmode=disable" go test ./...
```

### Environment Variables

| Variable | Development | Test | Production |
|----------|-------------|------|------------|
| DATABASE_URL | postgres://postgres:123456@localhost:5432/development?sslmode=disable | postgres://postgres:123456@localhost:5432/test?sslmode=disable | Supabase serverless URL |

## Thread Safety

- **DB instance is thread-safe** — Uses pgx connection pool internally
- **Concurrent queries** — Multiple goroutines can use the same DB instance

## Out of Scope

- Connection pooling configuration (relies on provider)
- Query caching
- Read replicas
- Explicit transaction support (for now)
- User authentication tables (handled separately)
- Community/credits tables (future module)

## Success Criteria

1. **Schema management**: Atlas schema applies cleanly to fresh database
2. **Code generation**: sqlc generates correct, type-safe Go code
3. **Connection handling**: Successfully connects via DATABASE_URL
4. **Fingerprint matching**: Finds videos with matching fingerprints within threshold
5. **CRUD operations**: All basic operations work for videos, transcriptions, translations, jobs
6. **Error handling**: Returns appropriate sentinel errors
7. **Docker setup**: Local dev environment starts with single command
8. **Test isolation**: Tests use separate database, don't affect development data

## Dependencies

### Go Dependencies

```
module github.com/prethora/echosub_db

go 1.21

require (
    github.com/jackc/pgx/v5 v5.5.0
    github.com/google/uuid v1.5.0
)
```

### Development Tools

- **Atlas CLI** — Schema management
- **sqlc CLI** — Query code generation
- **Docker** — Local PostgreSQL

### No Runtime Dependencies

The built binary requires only network access to PostgreSQL. No external runtime dependencies.